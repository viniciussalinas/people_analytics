# -*- coding: utf-8 -*-
"""people-analytics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iJPVHR7eU0HzBddedD6X3hrBcoOyaUIj
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
import pandas as pd
import seaborn as sns
import statsmodels.api as sm

df = pd.read_csv('people_analytics_data.csv', index_col=None)

df.isnull().any()

df.head()

df['Área'].replace(['Tribo Digital CLF','Tribo Digital (PE+CE)','Tribo Digital BH2','Tribo Digital SP2',
                    'Tribo Digital ISP1','Tribo Digital BH1','Tribo Digital SP3','Tribo Digital PR1',
                    'Tribo Digital Cursinho','Tribo Presencial RJ1+ISP1','Tribo Digital SP1'],
                   [0,1,2,3,4,5,6,7,8,9,10],inplace=True)
df['Status'].replace(['Inativo','Ativo'],[0,1],inplace=True)
df['Formação'].replace(['1 Formação','2 Formação','3 Formação','4 Formação','5 Formação'],[0,1,2,3,4],inplace=True)
df['Sexo'].replace(['Male','Female'],[0,1],inplace=True)

df.head()

df.dtypes

ativos = df.Status.value_counts()/150
ativos

# Taxa de demissão é igual a 18%

colabs_ativos = df.groupby('Status')
colabs_ativos.mean()

df.describe()

plt.figure(figsize=(16,8))

correlacao = df.corr()
correlacao = (correlacao)
sns.heatmap(correlacao,xticklabels=correlacao.columns.values,yticklabels=correlacao.columns.values,annot=True,
            cmap="YlGnBu",linewidths=0)

correlacao

tb_area_ativos = pd.crosstab(index=df['Formação'],columns=df['Status'])
tb_area_ativos.plot(kind='bar',figsize=(16,8),stacked=True)

df.groupby(['Área','Status']).size().groupby(level=0).apply(
    lambda x: 100 * x / x.sum()
).unstack().plot(kind='bar',figsize=(16,8),stacked=True)

plt.gca().yaxis.set_major_formatter(mtick.PercentFormatter())
plt.show()

tb_area_ativos = pd.crosstab(index=df['Sexo'],columns=df['Português'])
tb_area_ativos.plot(kind='bar',figsize=(16,8),stacked=True)

fig = plt.figure(figsize=(20,6))
ax=sns.kdeplot(df.loc[(df['Status']==0),'Total Horas'],color='c',shade=True,label='Saiu da companhia')
ax=sns.kdeplot(df.loc[(df['Status']==1),'Total Horas'],color='r',shade=True,label='Não saiu da companhia')
plt.title('Total de Horas Trabalhadas nos Últimos dois Meses')

fig = plt.figure(figsize=(20,6))
ax=sns.kdeplot(df.loc[(df['Status']==0),'Horas CLF'],color='c',shade=True,label='Saiu da companhia')
ax=sns.kdeplot(df.loc[(df['Status']==1),'Horas CLF'],color='r',shade=True,label='Não saiu da companhia')
plt.title('Total de Horas Trabalhadas nos Últimos dois Meses')

fig = plt.figure(figsize=(6,8))

sns.boxplot(x='Status',y='Total Horas',data=df,color='r')

fig = plt.figure(figsize=(6,8))

sns.boxplot(x='Status',y='Horas CLF',data=df,color='r')

fig = plt.figure(figsize=(6,8))

sns.boxplot(x='Status',y='Horas Semana Regular',data=df,color='r')

fig = plt.figure(figsize=(6,8))

sns.boxplot(x='Status',y='Horas Geração de Demanda',data=df,color='r')

sns.lmplot(x='Horas Geração de Demanda',y='Horas Semana Regular',data=df[df.Status==0],fit_reg=False,hue='Status',palette='Set2',height=4)

import statsmodels.api as sm
from sklearn.model_selection import train_test_split

df['int'] = 1
var = ['Horas Geração de Demanda','Horas Semana Regular','int','Status']
df = df[var]

alvo = 'Status'
x = df.drop('Status',axis=1)
y = df[alvo]

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.4,random_state=27,stratify=y)
x_train.head()

iv = ['Horas Geração de Demanda','Horas Semana Regular','int']
logReg = sm.Logit(y_train,x_train[iv])
regressao = logReg.fit()
regressao.summary
regressao.params

coeficiente = regressao.params

def probabilidade_permanencia (coeficiente, horas_geracao_demanda,horas_semana_regular):
    return coeficiente[0]*horas_geracao_demanda+coeficiente[1]*horas_semana_regular+coeficiente[2]

import numpy as np

colaborador_1 = probabilidade_permanencia(coeficiente,5,65)
colaborador_2 = probabilidade_permanencia(coeficiente,70,0)

prob_1 = np.exp(colaborador_1) / (1+np.exp(colaborador_1))
prob_2 = np.exp(colaborador_2) / (1+np.exp(colaborador_2))

prob_1

prob_2

